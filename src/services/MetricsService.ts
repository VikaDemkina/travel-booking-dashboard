import { Octokit } from '@octokit/rest';\n\nexport interface BuildMetric {\n  repository: string;\n  branch: string;\n  commit: string;\n  buildTime: number; // in seconds\n  status: 'success' | 'failure';\n  date: string;\n}\n\nexport interface DeployMetric {\n  repository: string;\n  environment: string;\n  status: 'success' | 'failure';\n  deployTime: number; // in seconds\n  date: string;\n}\n\nexport class MetricsService {\n  private octokit: Octokit;\n  private owner: string = 'VikaDemkina';\n  private repos = [\n    'travel-booking-shared-lib',\n    'travel-booking-root-config',\n    'travel-booking-auth',\n    'travel-booking-tours',\n    'travel-booking-admin',\n    'travel-booking-client'\n  ];\n\n  constructor(token: string) {\n    this.octokit = new Octokit({ auth: token });\n  }\n\n  async fetchBuildMetrics(): Promise<BuildMetric[]> {\n    const metrics: BuildMetric[] = [];\n\n    for (const repo of this.repos) {\n      try {\n        // Fetch workflow runs\n        const { data: workflowRuns } = await this.octokit.actions.listWorkflowRunsForRepo({\n          owner: this.owner,\n          repo,\n          per_page: 10\n        });\n\n        // Process each workflow run\n        for (const run of workflowRuns.workflow_runs) {\n          // Fetch artifacts for this run\n          const { data: artifacts } = await this.octokit.actions.listWorkflowRunArtifacts({\n            owner: this.owner,\n            repo,\n            run_id: run.id\n          });\n\n          // Find build-metrics artifact\n          const metricsArtifact = artifacts.artifacts.find(a => a.name === 'build-metrics');\n          \n          if (metricsArtifact) {\n            // Download and process artifact\n            // This is a simplified version, in a real app you would download and parse the artifact\n            metrics.push({\n              repository: repo,\n              branch: run.head_branch || 'unknown',\n              commit: run.head_sha,\n              buildTime: Math.floor(Math.random() * 120) + 30, // Simulated build time\n              status: run.conclusion === 'success' ? 'success' : 'failure',\n              date: run.created_at\n            });\n          }\n        }\n      } catch (error) {\n        console.error(`Error fetching metrics for ${repo}:`, error);\n      }\n    }\n\n    return metrics;\n  }\n\n  async fetchDeployMetrics(): Promise<DeployMetric[]> {\n    const metrics: DeployMetric[] = [];\n\n    for (const repo of this.repos) {\n      try {\n        // Fetch deployments\n        const { data: deployments } = await this.octokit.repos.listDeployments({\n          owner: this.owner,\n          repo\n        });\n\n        // Process each deployment\n        for (const deployment of deployments) {\n          // Fetch deployment statuses\n          const { data: statuses } = await this.octokit.repos.listDeploymentStatuses({\n            owner: this.owner,\n            repo,\n            deployment_id: deployment.id\n          });\n\n          if (statuses.length > 0) {\n            const latestStatus = statuses[0];\n            \n            metrics.push({\n              repository: repo,\n              environment: deployment.environment || 'production',\n              status: latestStatus.state === 'success' ? 'success' : 'failure',\n              deployTime: Math.floor(Math.random() * 60) + 10, // Simulated deploy time\n              date: latestStatus.created_at\n            });\n          }\n        }\n      } catch (error) {\n        console.error(`Error fetching deploy metrics for ${repo}:`, error);\n      }\n    }\n\n    return metrics;\n  }\n\n  async getAverageBuildTime(): Promise<{[repo: string]: number}> {\n    const buildMetrics = await this.fetchBuildMetrics();\n    const result: {[repo: string]: number} = {};\n    \n    // Group by repository\n    const groupedByRepo = buildMetrics.reduce((acc, metric) => {\n      if (!acc[metric.repository]) {\n        acc[metric.repository] = [];\n      }\n      acc[metric.repository].push(metric.buildTime);\n      return acc;\n    }, {} as {[repo: string]: number[]});\n    \n    // Calculate average for each repository\n    for (const [repo, times] of Object.entries(groupedByRepo)) {\n      const sum = times.reduce((a, b) => a + b, 0);\n      result[repo] = sum / times.length;\n    }\n    \n    return result;\n  }\n\n  async getBuildSuccessRate(): Promise<{[repo: string]: number}> {\n    const buildMetrics = await this.fetchBuildMetrics();\n    const result: {[repo: string]: number} = {};\n    \n    // Group by repository\n    const groupedByRepo = buildMetrics.reduce((acc, metric) => {\n      if (!acc[metric.repository]) {\n        acc[metric.repository] = { total: 0, success: 0 };\n      }\n      acc[metric.repository].total += 1;\n      if (metric.status === 'success') {\n        acc[metric.repository].success += 1;\n      }\n      return acc;\n    }, {} as {[repo: string]: {total: number, success: number}});\n    \n    // Calculate success rate for each repository\n    for (const [repo, counts] of Object.entries(groupedByRepo)) {\n      result[repo] = (counts.success / counts.total) * 100;\n    }\n    \n    return result;\n  }\n\n  async getDeploySuccessRate(): Promise<{[repo: string]: number}> {\n    const deployMetrics = await this.fetchDeployMetrics();\n    const result: {[repo: string]: number} = {};\n    \n    // Group by repository\n    const groupedByRepo = deployMetrics.reduce((acc, metric) => {\n      if (!acc[metric.repository]) {\n        acc[metric.repository] = { total: 0, success: 0 };\n      }\n      acc[metric.repository].total += 1;\n      if (metric.status === 'success') {\n        acc[metric.repository].success += 1;\n      }\n      return acc;\n    }, {} as {[repo: string]: {total: number, success: number}});\n    \n    // Calculate success rate for each repository\n    for (const [repo, counts] of Object.entries(groupedByRepo)) {\n      result[repo] = (counts.success / counts.total) * 100;\n    }\n    \n    return result;\n  }\n}